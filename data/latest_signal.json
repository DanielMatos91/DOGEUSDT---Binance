import os, json, time, requests
import pandas as pd, numpy as np
from datetime import datetime, timezone

SYMBOL   = os.getenv("SYMBOL", "DOGEUSDT")
INTERVAL = os.getenv("INTERVAL", "1h")
DAYS     = int(os.getenv("DAYS", "10"))

INTERVAL_TO_MIN = {"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":240,"6h":360,"8h":480,"12h":720,"1d":1440}
def to_ms(dt): return int(dt.timestamp()*1000)

def get_futures_klines(symbol="DOGEUSDT", interval="1h", days=10):
    limit = 1500
    step  = INTERVAL_TO_MIN[interval]
    total = int(days*24*60/step)
    iters = total//limit + 1
    end   = datetime.now(tz=timezone.utc)
    frames=[]
    for _ in range(iters):
        url = f"https://fapi.binance.com/fapi/v1/klines?symbol={symbol}&interval={interval}&limit={limit}&endTime={to_ms(end)}"
        r = requests.get(url, timeout=30); r.raise_for_status()
        data = r.json()
        if not data: break
        df = pd.DataFrame(data, columns=["open_time","open","high","low","close","volume","close_time","qav","trades","tbbav","tbqav","ignore"])
        frames.append(df)
        first_open = int(df.iloc[0]["open_time"])
        end = datetime.fromtimestamp(first_open/1000, tz=timezone.utc)
        time.sleep(0.2)
    out = pd.concat(frames, ignore_index=True)
    out["timestamp"] = pd.to_datetime(out["open_time"], unit="ms", utc=True)
    for c in ["open","high","low","close","volume"]:
        out[c] = out[c].astype(float)
    return out[["timestamp","open","high","low","close","volume"]].sort_values("timestamp").reset_index(drop=True)

def compute_indicators(df, ema_fast=8, ema_slow=20, rsi_period=21, slope_window=5, vol_window=14):
    dd = df.copy()
    dd["EMA_FAST"] = dd["close"].ewm(span=ema_fast, adjust=False).mean()
    dd["EMA_SLOW"] = dd["close"].ewm(span=ema_slow, adjust=False).mean()
    delta = dd["close"].diff()
    gain = delta.clip(lower=0); loss = (-delta).clip(lower=0)
    avg_gain = gain.rolling(rsi_period).mean(); avg_loss = loss.rolling(rsi_period).mean()
    rs = avg_gain / avg_loss
    dd["RSI"] = 100 - (100/(1+rs))
    dd["Volatility"] = dd["close"].rolling(vol_window).std()
    def _slope(x):
        x=np.asarray(x); t=np.arange(len(x))
        if len(x)<2: return np.nan
        m,_=np.polyfit(t,x,1); return m
    dd["Slope"] = dd["close"].rolling(slope_window).apply(_slope, raw=False)
    return dd.dropna().reset_index(drop=True)

def generate_signal_row(row):
    if row["EMA_FAST"]>row["EMA_SLOW"] and row["RSI"]>50 and row["Slope"]>0: return "BUY"
    if row["EMA_FAST"]<row["EMA_SLOW"] and row["RSI"]<50 and row["Slope"]<0: return "SELL"
    return "HOLD"

def main():
    df = get_futures_klines(SYMBOL, INTERVAL, DAYS)
    df = compute_indicators(df, 8, 20, 21, 5, 14)
    last = df.iloc[-1]
    signal = generate_signal_row(last)
    payload = {
        "symbol": SYMBOL,
        "interval": INTERVAL,
        "timestamp": str(last["timestamp"]),
        "close": float(last["close"]),
        "signal": signal,
        "rsi": float(last["RSI"]),
        "ema_fast": float(last["EMA_FAST"]),
        "ema_slow": float(last["EMA_SLOW"]),
        "slope": float(last["Slope"]),
        "volatility": float(last["Volatility"]) if not np.isnan(last["Volatility"]) else None,
        "sl": float(last["close"]*0.98),
        "tp": float(last["close"]*1.04),
        "_generated_at_utc": datetime.now(timezone.utc).isoformat()
    }
    # garante pasta data/
    os.makedirs("data", exist_ok=True)
    with open("data/latest_signal.json", "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
    print("Wrote data/latest_signal.json")
    print(payload)

if __name__ == "__main__":
    main()
